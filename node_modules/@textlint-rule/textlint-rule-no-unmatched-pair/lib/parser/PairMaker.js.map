{"version":3,"sources":["../../src/parser/PairMaker.js"],"names":["PAIR_MARKS","key","start","end","PAIR_MARKS_ENTRIES","map","mark","flat","PAIR_MARKS_KEY_Map","Map","matchPair","string","get","PairMaker","sourceCode","read","matchedPair","isInContext","pair","find","leaveContext","enterContext"],"mappings":"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","sourcesContent":["/**\n * Mark pair character\n * PairMarker aim to mark pair string as a single sentence.\n *\n * For example, Following sentence has two period(。). but it should treat a single sentence\n *\n * > I hear \"I'm back to home.\" from radio.\n *\n * https://ja.wikipedia.org/wiki/%E6%8B%AC%E5%BC%A7\n */\n/**\n * @typedef {{key:string,start:string,end:string}[]} PairMark\n */\nconst PAIR_MARKS = [\n    {\n        key: \"double quote\",\n        start: `\"`,\n        end: `\"`\n    },\n    {\n        key: \"angled bracket[]\",\n        start: `[`,\n        end: `]`\n    },\n    {\n        key: \"round bracket()\",\n        start: `(`,\n        end: `)`\n    },\n    {\n        key: \"curly brace{}\",\n        start: `{`,\n        end: `}`\n    },\n    {\n        key: \"かぎ括弧「」\",\n        start: `「`,\n        end: `」`\n    },\n    {\n        key: \"丸括弧（）\",\n        start: `（`,\n        end: `）`\n    },\n    {\n        key: \"二重かぎ括弧『』\",\n        start: `『`,\n        end: `』`\n    },\n    {\n        key: \"波括弧｛｝\",\n        start: `｛`,\n        end: `｝`\n    },\n    {\n        key: \"角括弧［］\",\n        start: `［`,\n        end: `］`\n    },\n    {\n        key: \"重角括弧〚〛\",\n        start: `〚`,\n        end: `〛`\n    },\n    {\n        key: \"隅付き括弧【】\",\n        start: `【`,\n        end: `】`\n    }\n];\n\n// create entries\n// [start.key, mark]\n// [end.key, mark]\nconst PAIR_MARKS_ENTRIES = PAIR_MARKS.map(mark => {\n    return [\n        [mark.start, mark],\n        [mark.end, mark]\n    ];\n}).flat(1);\n\n/**\n * Optimized Map\n * @type Map<string, {key:string,start:string,end:string}>\n */\nconst PAIR_MARKS_KEY_Map = new Map(PAIR_MARKS_ENTRIES);\nconst matchPair = (string) => {\n    return PAIR_MARKS_KEY_Map.get(string);\n}\n// For readme\n// console.log(PAIR_MARKS.map(pair => `- ${pair.key}: \\`${pair.start}\\` and \\`${pair.end}\\``).join(\"\\n\"));\nexport class PairMaker {\n    /**\n     * @param {import(\"./SourceCode\").SourceCode} sourceCode \n     * @returns \n     */\n    mark(sourceCode) {\n        const string = sourceCode.read();\n        if (!string) {\n            return;\n        }\n\n        const matchedPair = matchPair(string)\n        if (!matchedPair){\n            return;\n        }\n        // support nested pair\n        // {\"{test}\"}\n        if (sourceCode.isInContext(matchedPair)) {\n            // check that string is end mark?\n            const pair = PAIR_MARKS.find(pair => pair.end === string);\n            if (pair) {\n                sourceCode.leaveContext(pair);\n            }\n        } else {\n            const pair = PAIR_MARKS.find(pair => pair.start === string);\n            if (pair) {\n                sourceCode.enterContext(pair);\n            }\n        }\n    }\n}\n"],"file":"PairMaker.js"}