"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadRawConfig = exports.loadConfig = exports.loadPackagesFromRawConfig = void 0;
const rc_config_loader_1 = require("rc-config-loader");
const textlint_module_resolver_1 = require("./textlint-module-resolver");
const loader_1 = require("./loader");
/**
 * Load packages in RawConfig and return loaded config object
 * @param options
 */
const loadPackagesFromRawConfig = (options) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f;
    // TODO: validation
    // Search textlint's module
    const moduleResolver = new textlint_module_resolver_1.TextLintModuleResolver({
        rulesBaseDirectory: options.node_moduleDir
    });
    // rules
    const { rules, rulesError } = yield (0, loader_1.loadRules)({
        rulesObject: (_a = options.rawConfig.rules) !== null && _a !== void 0 ? _a : {},
        moduleResolver,
        testReplaceDefinitions: (_b = options.testReplaceDefinitions) === null || _b === void 0 ? void 0 : _b.rule
    });
    // filterRules
    const { filterRules, filterRulesError } = yield (0, loader_1.loadFilterRules)({
        rulesObject: (_c = options.rawConfig.filters) !== null && _c !== void 0 ? _c : {},
        moduleResolver,
        testReplaceDefinitions: (_d = options.testReplaceDefinitions) === null || _d === void 0 ? void 0 : _d.filterRules
    });
    // plugins
    const { plugins, pluginsError } = yield (0, loader_1.loadPlugins)({
        pluginsObject: (_e = options.rawConfig.plugins) !== null && _e !== void 0 ? _e : {},
        moduleResolver,
        testReplaceDefinitions: (_f = options.testReplaceDefinitions) === null || _f === void 0 ? void 0 : _f.plugins
    });
    if (rulesError) {
        return {
            ok: false,
            error: rulesError
        };
    }
    if (filterRulesError) {
        return {
            ok: false,
            error: filterRulesError
        };
    }
    if (pluginsError) {
        return {
            ok: false,
            error: pluginsError
        };
    }
    const loadedConfig = {
        rules,
        plugins,
        filterRules
    };
    // TODO: after validation
    return {
        ok: true,
        config: loadedConfig
    };
});
exports.loadPackagesFromRawConfig = loadPackagesFromRawConfig;
/**
 *  Load config file and return config object that is loaded rule instance.
 * @param options
 */
const loadConfig = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const rawResult = yield (0, exports.loadRawConfig)(options);
    if (!rawResult.ok) {
        return {
            ok: false,
            error: rawResult.error
        };
    }
    const packageOptions = {
        rawConfig: rawResult.rawConfig,
        node_moduleDir: options.node_modulesDir,
        testReplaceDefinitions: options.testReplaceDefinitions
    };
    const result = yield (0, exports.loadPackagesFromRawConfig)(options.preLoadingPackage ? options.preLoadingPackage(packageOptions) : packageOptions);
    if (!result.ok) {
        return {
            ok: false,
            configFilePath: rawResult.configFilePath,
            error: result.error
        };
    }
    return {
        ok: true,
        config: result.config,
        configFilePath: rawResult.configFilePath,
        rawConfig: rawResult.rawConfig
    };
});
exports.loadConfig = loadConfig;
/**
 *  Load config file and return parsed config object that is not loaded rule instance
 *  It is just JSON present for config file. Raw data
 * @param options
 */
const loadRawConfig = (options) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const results = (0, rc_config_loader_1.rcFile)("textlint", {
            cwd: options.cwd,
            configFileName: options.configFilePath,
            packageJSON: {
                fieldName: "textlint"
            }
        });
        // Not Found
        if (!results) {
            return {
                ok: false,
                error: {
                    message: "textlint config is not found",
                    errors: [
                        new Error(`textlint config is not found
                
textlint require .textlintrc config file.
The config file define the use of rules.`)
                    ]
                }
            };
        }
        return {
            ok: true,
            rawConfig: results.config,
            configFilePath: results.filePath
        };
    }
    catch (error) {
        return {
            ok: false,
            error: {
                message: "textlint config is not found",
                errors: [error instanceof Error ? error : new Error(String(error))]
            }
        };
    }
});
exports.loadRawConfig = loadRawConfig;
//# sourceMappingURL=config-loader.js.map