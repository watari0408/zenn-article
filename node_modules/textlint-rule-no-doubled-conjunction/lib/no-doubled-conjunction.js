// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _textlintRuleHelper = require("textlint-rule-helper");

var _kuromojin = require("kuromojin");

var _sentenceSplitter = require("sentence-splitter");

var _textlintUtilToString = require("textlint-util-to-string");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/*
    1. Paragraph Node -> text
    2. text -> sentences
    3. tokenize sentence
    4. report error if found word that match the rule.

    TODO: need abstraction
 */
function _default(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var helper = new _textlintRuleHelper.RuleHelper(context);
  var {
    Syntax,
    report,
    RuleError
  } = context;
  return {
    [Syntax.Paragraph](node) {
      if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
        return;
      }

      var source = new _textlintUtilToString.StringSource(node);
      var text = source.toString();

      var isSentenceNode = node => node.type === _sentenceSplitter.Syntax.Sentence;

      var sentences = (0, _sentenceSplitter.split)(text, {
        SeparatorParser: {
          separatorCharacters: [".", // period
          "．", // (ja) zenkaku-period
          "。", // (ja) 句点
          "?", // question mark
          "!", //  exclamation mark
          "？", // (ja) zenkaku question mark
          "！" // (ja) zenkaku exclamation mark
          ]
        }
      }).filter(isSentenceNode); // if not have a sentence, early return
      // It is for avoiding error of emptyArray.reduce().

      if (sentences.length === 0) {
        return;
      }

      var selectConjenction = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (sentence) {
          var tokens = yield (0, _kuromojin.tokenize)(sentence.raw);
          var conjunctionTokens = tokens.filter((token, index) => {
            var prevToken = tokens[index - 1]; // スペースが切れ目として認識されてしまう問題を回避
            // https://github.com/textlint-ja/textlint-rule-no-doubled-conjunction/issues/14

            if (prevToken && prevToken.pos_detail_1 === "空白" && token.pos === "接続詞") {
              return false;
            }

            return token.pos === "接続詞";
          });
          return [sentence, conjunctionTokens];
        });

        return function selectConjenction(_x) {
          return _ref.apply(this, arguments);
        };
      }();

      var prev_token = null;
      return Promise.all(sentences.map(selectConjenction)).then(result => result.reduce((prev, current) => {
        var [sentence, current_tokens] = current;
        var [prev_sentence, prev_tokens] = prev;
        var token = prev_token;

        if (prev_tokens && prev_tokens.length > 0) {
          token = prev_tokens[0];
        }

        if (current_tokens.length > 0) {
          if (token && current_tokens[0].surface_form === token.surface_form) {
            var conjunctionSurface = token.surface_form;
            var originalIndex = source.originalIndexFromPosition({
              line: sentence.loc.start.line,
              column: sentence.loc.start.column + (current_tokens[0].word_position - 1)
            }); // padding position

            var padding = {
              index: originalIndex
            };
            report(node, new RuleError("\u540C\u3058\u63A5\u7D9A\u8A5E\uFF08".concat(conjunctionSurface, "\uFF09\u304C\u9023\u7D9A\u3057\u3066\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059\u3002"), padding));
          }
        }

        prev_token = token;
        return current;
      }));
    }

  };
}

;
//# sourceMappingURL=no-doubled-conjunction.js.map