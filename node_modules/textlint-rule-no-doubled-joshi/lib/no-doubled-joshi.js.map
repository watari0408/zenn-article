{"version":3,"file":"no-doubled-joshi.js","names":["createSurfaceKeyMap","tokens","filter","is助詞Token","reduce","keyMap","token","tokenKey","createKeyFromKey","push","matchExceptionRule","pos_detail_1","surface_form","length","defaultOptions","min_interval","strict","allow","separatorCharacters","commaCharacters","toTextWithPrevWord","sentence","index","indexOf","prevToken","DEFAULT_RESULT","originalIndex","word_position","undefined","originalNode","children","find","node","range","type","raw","report","context","options","helper","RuleHelper","minInterval","Error","isStrict","Syntax","RuleError","is読点Token","create読点Matcher","Paragraph","isChildNode","Link","Image","BlockQuote","Emphasis","isSentenceNode","SentenceSyntax","Sentence","txtParentNode","splitSentences","SeparatorParser","sentences","checkSentence","sentenceSource","StringSource","replacer","maskValue","Code","text","toString","tokenize","concatTokens","concatJoishiTokens","countableTokens","is括弧Token","includes","joshiTokenSurfaceKeyMap","Object","keys","forEach","key","joshiTokenSurfaceTokens","joshiName","restoreToSurfaceFromKey","prev","current","startPosition","otherPosition","differenceIndex","startWord","endWord","originalIndexFromIndex","Promise","all","map"],"sources":["../src/no-doubled-joshi.ts"],"sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nimport { splitAST as splitSentences, Syntax as SentenceSyntax, SentenceNode } from \"sentence-splitter\";\nimport { tokenize, KuromojiToken } from \"kuromojin\";\nimport {\n    is助詞Token,\n    create読点Matcher,\n    concatJoishiTokens,\n    createKeyFromKey,\n    restoreToSurfaceFromKey,\n    is括弧Token,\n} from \"./token-utils\";\nimport type { TxtNode, TxtParentNode } from \"@textlint/ast-node-types\";\nimport type { TextlintRuleModule } from \"@textlint/types\";\nimport { StringSource } from \"textlint-util-to-string\";\n\n/**\n * Create token map object\n * {\n *  \"は:助詞.係助詞\": [token, token]\n * }\n * @param tokens\n * @returns {*}\n */\nfunction createSurfaceKeyMap(tokens: KuromojiToken[]): { [index: string]: KuromojiToken[] } {\n    // 助詞のみを対象とする\n    return tokens.filter(is助詞Token).reduce((keyMap, token) => {\n        // \"は:助詞.係助詞\" : [token]\n        const tokenKey = createKeyFromKey(token);\n        if (!keyMap[tokenKey]) {\n            keyMap[tokenKey] = [];\n        }\n        keyMap[tokenKey].push(token);\n        return keyMap;\n    }, {} as { [index: string]: KuromojiToken[] });\n}\n\nfunction matchExceptionRule(tokens: KuromojiToken[]) {\n    const token = tokens[0];\n    // \"の\" の重なりは例外\n    if (token.pos_detail_1 === \"連体化\") {\n        return true;\n    }\n    // \"を\" の重なりは例外\n    if (token.pos_detail_1 === \"格助詞\" && token.surface_form === \"を\") {\n        return true;\n    }\n    // 接続助詞 \"て\" の重なりは例外\n    if (token.pos_detail_1 === \"接続助詞\" && token.surface_form === \"て\") {\n        return true;\n    }\n    // 並立助詞は例外\n    // 登ったり降りたり\n    if (tokens.length === 2 && tokens[0].pos_detail_1 === \"並立助詞\" && tokens[1].pos_detail_1 === \"並立助詞\") {\n        return true;\n    }\n    return false;\n}\n\n/*\n default options\n */\nconst defaultOptions = {\n    min_interval: 1,\n    strict: false,\n    allow: [],\n    separatorCharacters: [\n        \".\", // period\n        \"．\", // (ja) zenkaku-period\n        \"。\", // (ja) 句点\n        \"?\", // question mark\n        \"!\", //  exclamation mark\n        \"？\", // (ja) zenkaku question mark\n        \"！\", // (ja) zenkaku exclamation mark\n    ],\n    commaCharacters: [\n        \"、\",\n        \"，\", // 全角カンマ\n    ],\n};\n\nexport interface Options {\n    /**\n     * 助詞の最低間隔値\n     * 指定した間隔値以下で同じ助詞が出現した場合エラーが出力されます\n     * デフォルトは1なので、同じ助詞が連続した場合にエラーとなります。\n     */\n    min_interval?: number;\n    /**\n     * デフォルトの例外パターンもエラーにするかどうか\n     * デフォルト: false\n     */\n    strict?: boolean;\n    /**\n     * 複数回の出現を許す助詞の配列\n     * 例): [\"も\", \"や\"]\n     */\n    allow?: string[];\n    /**\n     * 文の区切りとなる文字(句点)の配列\n     */\n    separatorCharacters?: string[];\n    /**\n     * 読点となる文字の配列\n     */\n    commaCharacters?: string[];\n}\n\ninterface ToTextWithPrevTokenParams {\n    tokens: KuromojiToken[];\n    sentence: SentenceNode;\n}\n\n\n/**\n * \"~~~~~~{助詞}\" から {Token}\"{助詞}\" という形になるように、前の単語を含めた助詞の文字列を取得する\n *\n * 前のNodeがStrの場合は、一つ前のTokenを取得する\n * {Str}{助詞} -> {Token}\"{助詞}\"\n *\n * それ以外のNodeの場合は、そのNodeの文字列を取得する\n * {Code}{助詞} -> {Code}\"{助詞}\"\n * {Strong}{助詞} -> {Strong}\"{助詞}\"\n *\n * @param token\n * @param tokens\n * @param sentence\n */\nconst toTextWithPrevWord = (token: KuromojiToken, { tokens, sentence }: ToTextWithPrevTokenParams) => {\n    const index = tokens.indexOf(token);\n    const prevToken = tokens[index - 1];\n    // 前のTokenがない場合は、Tokenのsurface_formを返す\n    const DEFAULT_RESULT = `\"${token.surface_form}\"`;\n    if (!prevToken) {\n        return DEFAULT_RESULT;\n    }\n    const originalIndex = prevToken.word_position - 1;\n    if (originalIndex === undefined) {\n        return DEFAULT_RESULT;\n    }\n    // Tokenの位置に該当するNodeを取得する\n    const originalNode = sentence.children.find(node => {\n        return node.range[0] <= originalIndex && originalIndex < node.range[1];\n    });\n    if (originalNode === undefined) {\n        return DEFAULT_RESULT;\n    }\n    if (originalNode.type === \"Str\") {\n        return `${prevToken.surface_form}\"${token.surface_form}\"`\n    }\n    return `${originalNode.raw}\"${token.surface_form}\"`;\n}\n/*\n 1. Paragraph Node -> text\n 2. text -> sentences\n 3. tokenize sentence\n 4. report error if found word that match the rule.\n */\nconst report: TextlintRuleModule<Options> = function (context, options = {}) {\n    const helper = new RuleHelper(context);\n    // 最低間隔値\n    const minInterval = options.min_interval !== undefined ? options.min_interval : defaultOptions.min_interval;\n    if (minInterval <= 0) {\n        throw new Error(\"options.min_intervalは1以上の数値を指定してください\");\n    }\n    const isStrict = options.strict || defaultOptions.strict;\n    const allow = options.allow || defaultOptions.allow;\n    const separatorCharacters = options.separatorCharacters || defaultOptions.separatorCharacters;\n    const commaCharacters = options.commaCharacters || defaultOptions.commaCharacters;\n    const { Syntax, report, RuleError } = context;\n    const is読点Token = create読点Matcher(commaCharacters);\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {\n                return;\n            }\n            const isSentenceNode = (node: TxtNode): node is SentenceNode => {\n                return node.type === SentenceSyntax.Sentence;\n            };\n            const txtParentNode = splitSentences(node as TxtParentNode, {\n                SeparatorParser: {\n                    separatorCharacters,\n                },\n            });\n            const sentences = txtParentNode.children.filter(isSentenceNode);\n            const checkSentence = async (sentence: SentenceNode) => {\n                // コードの中身は無視するため、無意味な文字列に置き換える\n                // @ts-expect-error: sentence-splitterが古いので\n                const sentenceSource = new StringSource(sentence, {\n                    replacer({ node, maskValue }) {\n                        /*\n                         * `obj.method` のCode Nodeのように、区切り文字として意味をもつノードがある場合に、\n                         * このルールでは単純に無視したいので、同じ文字数で意味のない文字列に置き換える\n                         */\n                        if (node.type === Syntax.Code) {\n                            return maskValue(\"ー\");\n                        }\n                        return;\n                    }\n                });\n                const text = sentenceSource.toString();\n                const tokens = await tokenize(text);\n                // 助詞 + 助詞は 一つの助詞として扱う\n                // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/15\n                // 連語(助詞)の対応\n                // http://www.weblio.jp/parts-of-speech/%E9%80%A3%E8%AA%9E(%E5%8A%A9%E8%A9%9E)_1\n                const concatTokens = concatJoishiTokens(tokens);\n                const countableTokens = concatTokens.filter((token) => {\n                    if (isStrict) {\n                        return is助詞Token(token);\n                    }\n                    // デフォルトでは、\"、\"などを間隔値の距離としてカウントする\n                    // \"(\"や\")\"などもトークンとしてカウントする\n                    // xxxx（xxx) xxx でカッコの中と外に距離を一つ増やす目的\n                    // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/31\n                    if (is括弧Token(token)) {\n                        return true;\n                    }\n                    // sentence-splitterでセンテンスに区切った場合、 \"Xは「カッコ書きの中の文」と言った。\" というように、「」の中の文は区切られない\n                    // そのため、トークナイズしたトークンで区切り文字となる文字(。や.）があった場合には、カウントを増やす　\n                    // デフォルトではmin_interval:1 なので、「今日は早朝から出発したが、定刻には間に合わなかった。定刻には間に合わなかったが、無事会場に到着した」のようなものがエラーではなくなる\n                    // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/40\n                    if (separatorCharacters.includes(token.surface_form)) {\n                        return true;\n                    }\n                    // \"、\" があると助詞同士の距離が開くようにすることで、並列的な\"、\"の使い方を許容する目的\n                    // https://github.com/azu/textlint-rule-no-doubled-joshi/issues/2\n                    if (is読点Token(token)) {\n                        return true;\n                    }\n                    return is助詞Token(token);\n                });\n                const joshiTokenSurfaceKeyMap = createSurfaceKeyMap(countableTokens);\n                /*\n                    # Data Structure\n\n                    joshiTokens = [tokenA, tokenB, tokenC, tokenD, tokenE, tokenF]\n                    joshiTokenSurfaceKeyMap = {\n                        \"は:助詞.係助詞\": [tokenA, tokenC, tokenE],\n                        \"で:助詞.係助詞\": [tokenB, tokenD, tokenF]\n                    }\n                    */\n                Object.keys(joshiTokenSurfaceKeyMap).forEach((key) => {\n                    const joshiTokenSurfaceTokens: KuromojiToken[] = joshiTokenSurfaceKeyMap[key];\n                    const joshiName = restoreToSurfaceFromKey(key);\n                    // check allow\n                    if (allow.includes(joshiName)) {\n                        return;\n                    }\n                    // strict mode ではない時例外を除去する\n                    if (!isStrict) {\n                        if (matchExceptionRule(joshiTokenSurfaceTokens)) {\n                            return;\n                        }\n                    }\n                    if (joshiTokenSurfaceTokens.length <= 1) {\n                        return; // no duplicated token\n                    }\n                    // if found differenceIndex less than\n                    // tokes are sorted ascending order\n                    joshiTokenSurfaceTokens.reduce((prev, current) => {\n                        const startPosition = countableTokens.indexOf(prev);\n                        const otherPosition = countableTokens.indexOf(current);\n                        // 助詞token同士の距離が設定値以下ならエラーを報告する\n                        const differenceIndex = otherPosition - startPosition;\n                        if (differenceIndex <= minInterval) {\n                            // 連続する助詞を集める\n                            const startWord = toTextWithPrevWord(prev, {\n                                tokens: tokens,\n                                sentence: sentence\n                            });\n                            const endWord = toTextWithPrevWord(current, {\n                                tokens: tokens,\n                                sentence: sentence\n                            });\n                            // padding positionを計算する\n                            const originalIndex = sentenceSource.originalIndexFromIndex(current.word_position - 1);\n                            report(\n                                // @ts-expect-error: SentenceNodeは独自であるため\n                                sentence,\n                                new RuleError(\n                                    `一文に二回以上利用されている助詞 \"${joshiName}\" がみつかりました。\n\n次の助詞が連続しているため、文を読みにくくしています。\n\n- ${startWord}\n- ${endWord}\n\n同じ助詞を連続して利用しない、文の中で順番を入れ替える、文を分割するなどを検討してください。\n`,\n                                    {\n                                        index: originalIndex,\n                                    }\n                                )\n                            );\n                        }\n                        return current;\n                    });\n                });\n            };\n            return Promise.all(sentences.map(checkSentence));\n        },\n    };\n};\nexport default report;\n"],"mappings":"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"}