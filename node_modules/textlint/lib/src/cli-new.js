"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli = void 0;
// LICENSE : MIT
const debug_1 = __importDefault(require("debug"));
const options_1 = require("./options");
const config_initializer_1 = require("./config/config-initializer");
const textlint_fixer_1 = require("./fixer/textlint-fixer");
const logger_1 = require("./util/logger");
const TextlintrcLoader_1 = require("./loader/TextlintrcLoader");
const CliLoader_1 = require("./loader/CliLoader");
const createLinter_1 = require("./createLinter");
const SeverityLevel_1 = require("./shared/type/SeverityLevel");
const cli_util_1 = require("./cli-util");
const formatter_1 = require("./formatter");
const debug = (0, debug_1.default)("textlint:cli");
const isStdinExecution = (executeOptions) => {
    return "text" in executeOptions;
};
const loadDescriptor = (cliOptions) => __awaiter(void 0, void 0, void 0, function* () {
    const cliDescriptor = yield (0, CliLoader_1.loadCliDescriptor)(cliOptions);
    const textlintrcDescriptor = cliOptions.textlintrc
        ? yield (0, TextlintrcLoader_1.loadTextlintrc)({
            configFilePath: cliOptions.config,
            node_modulesDir: cliOptions.rulesBaseDirectory
        })
        : yield (0, TextlintrcLoader_1.loadBuiltinPlugins)();
    return cliDescriptor.concat(textlintrcDescriptor);
});
/**
 * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as
 * for other Node.js programs to effectively run the CLI.
 */
exports.cli = {
    /**
     * Executes the CLI based on an array of arguments that is passed in.
     * @param {string|string[]} args The arguments to process.
     * @param {string} [text] The text to lint (used for TTY).
     * @returns {Promise<number>} The exit code for the operation.
     */
    execute(args, text) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentOptions;
            // version from package.json
            const pkgConf = yield import("read-pkg-up");
            const version = pkgConf.sync({ cwd: __dirname }).pkg.version;
            try {
                currentOptions = options_1.options.parse(args);
            }
            catch (error) {
                logger_1.Logger.error(error);
                return Promise.resolve(1);
            }
            const files = currentOptions._;
            if (currentOptions.version) {
                logger_1.Logger.log(`v${version}`);
            }
            else if (currentOptions.init) {
                return (0, config_initializer_1.createConfigFile)({
                    dir: process.cwd(),
                    verbose: !currentOptions.quiet
                });
            }
            else if (currentOptions.printConfig) {
                const descriptor = yield loadDescriptor(currentOptions);
                logger_1.Logger.log(JSON.stringify(descriptor, null, 4));
                return Promise.resolve(0);
            }
            else if (currentOptions.help || (!files.length && !text)) {
                logger_1.Logger.log(options_1.options.generateHelp());
            }
            else {
                // specify file name of stdin content
                const stdinFilename = currentOptions.stdinFilename;
                debug(`textlint --version: ${version}`);
                debug(`Running on ${text ? "text" : "files"}, stdin-filename: ${stdinFilename}`);
                if (text) {
                    if (!stdinFilename) {
                        throw new Error("Please specify --stdin-filename option");
                    }
                    return this.executeWithOptions({
                        cliOptions: currentOptions,
                        text,
                        stdinFilename
                    });
                }
                else {
                    return this.executeWithOptions({
                        cliOptions: currentOptions,
                        files
                    });
                }
            }
            return Promise.resolve(0);
        });
    },
    /**
     * execute with cli options
     * @returns {Promise<number>} exit status
     */
    executeWithOptions(executeOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const cliOptions = executeOptions.cliOptions;
            // cli > textlintrc
            // if cli and textlintrc have same option, cli option is prior.
            const descriptor = yield loadDescriptor(cliOptions);
            const hasRuleAtLeastOne = descriptor.rule.lintableDescriptors.length > 0;
            if (!hasRuleAtLeastOne) {
                (0, cli_util_1.showEmptyRuleWarning)();
                return Promise.resolve(1);
            }
            const linter = (0, createLinter_1.createLinter)({
                cache: cliOptions.cache,
                cacheLocation: cliOptions.cacheLocation,
                quiet: cliOptions.quiet,
                descriptor
            });
            if (cliOptions.fix) {
                // --fix
                const results = isStdinExecution(executeOptions)
                    ? [yield linter.fixText(executeOptions.text, executeOptions.stdinFilename)]
                    : yield linter.fixFiles(executeOptions.files);
                debug("fix results: %j", results);
                const fixer = new textlint_fixer_1.TextLintFixer();
                const formatter = yield (0, formatter_1.loadFixerFormatter)({
                    formatterName: cliOptions.format,
                    color: cliOptions.color
                });
                const output = formatter.format(results);
                // --dry-run
                if (cliOptions.dryRun) {
                    debug("Enable dry-run mode");
                    return Promise.resolve(0);
                }
                // modify file and return exit status
                yield fixer.write(results);
                if ((0, cli_util_1.printResults)(output, cliOptions)) {
                    if (cliOptions.outputFile) {
                        return 0; // if --output-file option is specified, exit status is always 0
                    }
                    // --fix result has remaining errors, return 1
                    const hasErrorMessage = results.some((result) => {
                        return result.remainingMessages.some((message) => message.severity === SeverityLevel_1.SeverityLevel.error);
                    });
                    return hasErrorMessage ? 1 : 0;
                }
                else {
                    return 2;
                }
            }
            else {
                // lint as default
                const results = isStdinExecution(executeOptions)
                    ? [yield linter.lintText(executeOptions.text, executeOptions.stdinFilename)]
                    : yield linter.lintFiles(executeOptions.files);
                debug("lint results: %j", results);
                const formatter = yield (0, formatter_1.loadLinterFormatter)({
                    formatterName: cliOptions.format,
                    color: cliOptions.color
                });
                const output = formatter.format(results);
                if ((0, cli_util_1.printResults)(output, cliOptions)) {
                    if (cliOptions.outputFile) {
                        return 0; // if --output-file option is specified, exit status is always 0
                    }
                    const hasErrorMessage = results.some((result) => {
                        return result.messages.some((message) => message.severity === SeverityLevel_1.SeverityLevel.error);
                    });
                    return hasErrorMessage ? 1 : 0;
                }
                else {
                    return 2;
                }
            }
        });
    }
};
//# sourceMappingURL=cli-new.js.map