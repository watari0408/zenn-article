// LICENSE : MIT
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli = void 0;
const feature_flag_1 = require("@textlint/feature-flag");
const debug_1 = __importDefault(require("debug"));
const options_1 = require("./options");
const textlint_engine_1 = require("./textlint-engine");
const textfix_engine_1 = require("./textfix-engine");
const config_1 = require("./config/config");
const config_initializer_1 = require("./config/config-initializer");
const textlint_fixer_1 = require("./fixer/textlint-fixer");
const logger_1 = require("./util/logger");
const lint_worker_master_1 = require("./parallel/lint-worker-master");
const cli_util_1 = require("./cli-util");
const debug = (0, debug_1.default)("textlint:cli");
/*
 cli.js is command line **interface**

 processing role is cli-engine.js.
 @see cli-engine.js
 */
/**
 * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as
 * for other Node.js programs to effectively run the CLI.
 */
exports.cli = {
    /**
     * Executes the CLI based on an array of arguments that is passed in.
     * @param {string|string[]} args The arguments to process.
     * @param {string} [text] The text to lint (used for TTY).
     * @returns {Promise<number>} The exit code for the operation.
     */
    execute(args, text) {
        let currentOptions;
        // version from package.json
        const pkgConf = require("read-pkg-up");
        const version = pkgConf.sync({ cwd: __dirname }).pkg.version;
        try {
            currentOptions = options_1.options.parse(args);
        }
        catch (error) {
            logger_1.Logger.error(error);
            return Promise.resolve(1);
        }
        const files = currentOptions._;
        if (currentOptions.version) {
            logger_1.Logger.log(`v${version}`);
        }
        else if (currentOptions.init) {
            return (0, config_initializer_1.createConfigFile)({
                dir: process.cwd(),
                verbose: !currentOptions.quiet
            });
        }
        else if (currentOptions.help || (!files.length && !text)) {
            logger_1.Logger.log(options_1.options.generateHelp());
        }
        else {
            // specify file name of stdin content
            const stdinFilename = currentOptions.stdinFilename;
            debug(`textlint --version: ${version}`);
            debug(`Running on ${text ? "text" : "files"}, stdin-filename: ${stdinFilename}`);
            if (currentOptions.parallel) {
                debug("textlint --parallel");
                (0, feature_flag_1.throwWithoutExperimental)("--parallel is experimental feature. It should be used with --experimental flag");
                return this.executeWithParallel(currentOptions, files);
            }
            return this.executeWithOptions(currentOptions, files, text, stdinFilename);
        }
        return Promise.resolve(0);
    },
    /**
     * execute with cli options
     * @param {object} cliOptions
     * @param {string[]} files files are file path list
     * @returns {Promise<number>} exit status
     */
    executeWithParallel(cliOptions, files) {
        const config = config_1.Config.initWithCLIOptions(cliOptions);
        if (cliOptions.fix) {
            // --fix
            const fixEngine = new textfix_engine_1.TextFixEngine(config);
            if (!fixEngine.hasRuleAtLeastOne()) {
                (0, cli_util_1.showEmptyRuleWarning)();
                return Promise.resolve(1);
            }
            const resultsPromise = (0, lint_worker_master_1.lintParallel)(files, {
                type: "fix",
                config: config,
                concurrency: cliOptions.maxConcurrency
            });
            return resultsPromise.then((results) => {
                debug("fix results: %j", results);
                const fixer = new textlint_fixer_1.TextLintFixer();
                const output = fixEngine.formatResults(results);
                (0, cli_util_1.printResults)(output, cliOptions);
                // --dry-run
                if (cliOptions.dryRun) {
                    debug("Enable dry-run mode");
                    return Promise.resolve(0);
                }
                // modify file and return exit status
                return fixer.write(results).then(() => {
                    return 0;
                });
            });
        }
        // lint as default
        const lintEngine = new textlint_engine_1.TextLintEngine(config);
        if (!lintEngine.hasRuleAtLeastOne()) {
            (0, cli_util_1.showEmptyRuleWarning)();
            return Promise.resolve(1);
        }
        const resultsPromise = (0, lint_worker_master_1.lintParallel)(files, {
            type: "lint",
            config: config,
            concurrency: cliOptions.maxConcurrency
        });
        return resultsPromise.then((results) => {
            debug("lint results: %j", results);
            const output = lintEngine.formatResults(results);
            if ((0, cli_util_1.printResults)(output, cliOptions)) {
                return lintEngine.isErrorResults(results) ? 1 : 0;
            }
            else {
                return 1;
            }
        });
    },
    /**
     * execute with cli options
     * @param {object} cliOptions
     * @param {string[]} files files are file path list
     * @param {string} [text]
     * @param {string} [stdinFilename]
     * @returns {Promise<number>} exit status
     */
    executeWithOptions(cliOptions, files, text, stdinFilename) {
        const config = config_1.Config.initWithCLIOptions(cliOptions);
        if (cliOptions.fix) {
            // --fix
            const fixEngine = new textfix_engine_1.TextFixEngine(config);
            if (!fixEngine.hasRuleAtLeastOne()) {
                (0, cli_util_1.showEmptyRuleWarning)();
                return Promise.resolve(1);
            }
            const resultsPromise = text
                ? fixEngine.executeOnText(text, stdinFilename)
                : fixEngine.executeOnFiles(files);
            return resultsPromise.then((results) => {
                debug("fix results: %j", results);
                const fixer = new textlint_fixer_1.TextLintFixer();
                const output = fixEngine.formatResults(results);
                (0, cli_util_1.printResults)(output, cliOptions);
                // --dry-run
                if (cliOptions.dryRun) {
                    debug("Enable dry-run mode");
                    return Promise.resolve(0);
                }
                // modify file and return exit status
                return fixer.write(results).then(() => {
                    return 0;
                });
            });
        }
        // lint as default
        const lintEngine = new textlint_engine_1.TextLintEngine(config);
        if (!lintEngine.hasRuleAtLeastOne()) {
            (0, cli_util_1.showEmptyRuleWarning)();
            return Promise.resolve(1);
        }
        const resultsPromise = text ? lintEngine.executeOnText(text, stdinFilename) : lintEngine.executeOnFiles(files);
        return resultsPromise.then((results) => {
            debug("lint results: %j", results);
            const output = lintEngine.formatResults(results);
            if ((0, cli_util_1.printResults)(output, cliOptions)) {
                return lintEngine.isErrorResults(results) ? 1 : 0;
            }
            else {
                return 1;
            }
        });
    }
};
//# sourceMappingURL=cli.js.map