// LICENSE : MIT
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLinter = void 0;
const kernel_1 = require("@textlint/kernel");
const find_util_1 = require("./util/find-util");
const execute_file_backer_manager_1 = require("./engine/execute-file-backer-manager");
const cache_backer_1 = require("./engine/execute-file-backers/cache-backer");
const path_1 = __importDefault(require("path"));
const crypto_1 = __importDefault(require("crypto"));
const read_pkg_up_1 = __importDefault(require("read-pkg-up"));
const promises_1 = __importDefault(require("fs/promises"));
const logger_1 = require("./util/logger");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)("textlint:createTextlint");
const createHashForDescriptor = (descriptor) => {
    try {
        const version = read_pkg_up_1.default.sync({ cwd: __dirname }).pkg.version;
        const toString = JSON.stringify(descriptor.toJSON());
        const md5 = crypto_1.default.createHash("md5");
        return md5.update(`${version}-${toString}`, "utf8").digest("hex");
    }
    catch (error) {
        // Fallback for some env
        // https://github.com/textlint/textlint/issues/597
        logger_1.Logger.warn("Use random value as hash because calculating hash value throw error", error);
        return crypto_1.default.randomBytes(20).toString("hex");
    }
};
const createLinter = (options) => {
    var _a, _b;
    const executeFileBackerManger = new execute_file_backer_manager_1.ExecuteFileBackerManager();
    const cacheBaker = new cache_backer_1.CacheBacker({
        cache: (_a = options.cache) !== null && _a !== void 0 ? _a : false,
        cacheLocation: (_b = options.cacheLocation) !== null && _b !== void 0 ? _b : path_1.default.resolve(process.cwd(), ".textlintcache"),
        hash: createHashForDescriptor(options.descriptor)
    });
    if (options.cache) {
        executeFileBackerManger.add(cacheBaker);
    }
    else {
        cacheBaker.destroyCache();
    }
    const kernel = new kernel_1.TextlintKernel({
        quiet: options.quiet
    });
    const baseOptions = options.descriptor.toKernelOptions();
    return {
        /**
         * Executes the current configuration on an array of file and directory names.
         * @param {String[]}  files An array of file and directory names.
         * @returns {Promise<TextlintResult[]>} The results for all files that were linted.
         */
        lintFiles(files) {
            return __awaiter(this, void 0, void 0, function* () {
                const patterns = (0, find_util_1.pathsToGlobPatterns)(files, {
                    extensions: options.descriptor.availableExtensions
                });
                const targetFiles = (0, find_util_1.findFiles)(patterns, {
                    ignoreFilePath: options.ignoreFile
                });
                const { availableFiles, unAvailableFiles } = (0, find_util_1.separateByAvailability)(targetFiles, {
                    extensions: options.descriptor.availableExtensions
                });
                debug("Process files", availableFiles);
                debug("No Process files that are un-support extensions:", unAvailableFiles);
                return executeFileBackerManger.process(availableFiles, (filePath) => __awaiter(this, void 0, void 0, function* () {
                    const absoluteFilePath = path_1.default.resolve(process.cwd(), filePath);
                    const fileContent = yield promises_1.default.readFile(filePath, "utf-8");
                    const kernelOptions = Object.assign({ ext: path_1.default.extname(filePath), filePath: absoluteFilePath }, baseOptions);
                    return kernel.lintText(fileContent, kernelOptions);
                }));
            });
        },
        lintText(text, filePath) {
            return __awaiter(this, void 0, void 0, function* () {
                const kernelOptions = Object.assign({ ext: path_1.default.extname(filePath), filePath }, baseOptions);
                return kernel.lintText(text, kernelOptions);
            });
        },
        // fix files
        fixFiles(files) {
            return __awaiter(this, void 0, void 0, function* () {
                const patterns = (0, find_util_1.pathsToGlobPatterns)(files, {
                    extensions: options.descriptor.availableExtensions
                });
                const targetFiles = (0, find_util_1.findFiles)(patterns, {
                    ignoreFilePath: options.ignoreFile
                });
                const { availableFiles, unAvailableFiles } = (0, find_util_1.separateByAvailability)(targetFiles, {
                    extensions: options.descriptor.availableExtensions
                });
                debug("Process files", availableFiles);
                debug("No Process files that are un-support extensions:", unAvailableFiles);
                return executeFileBackerManger.process(availableFiles, (filePath) => __awaiter(this, void 0, void 0, function* () {
                    const absoluteFilePath = path_1.default.resolve(process.cwd(), filePath);
                    const fileContent = yield promises_1.default.readFile(filePath, "utf-8");
                    const kernelOptions = Object.assign({ ext: path_1.default.extname(filePath), filePath: absoluteFilePath }, baseOptions);
                    return kernel.fixText(fileContent, kernelOptions);
                }));
            });
        },
        fixText(text, filePath) {
            return __awaiter(this, void 0, void 0, function* () {
                const kernelOptions = Object.assign({ ext: path_1.default.extname(filePath), filePath }, baseOptions);
                return kernel.fixText(text, kernelOptions);
            });
        }
    };
};
exports.createLinter = createLinter;
//# sourceMappingURL=createLinter.js.map