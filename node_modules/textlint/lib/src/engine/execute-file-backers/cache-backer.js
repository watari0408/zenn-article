// MIT Â© 2016 azu
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheBacker = void 0;
// @ts-expect-error
const file_entry_cache_1 = __importDefault(require("file-entry-cache"));
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)("textlint:CacheBacker");
class CacheBacker {
    /**
     * @param {Config} config
     */
    constructor(config) {
        this.config = config;
        /**
         * @type {boolean}
         */
        this.isEnabled = config.cache;
        this.fileCache = file_entry_cache_1.default.create(config.cacheLocation);
    }
    /**
     * @param {string} filePath
     * @returns {boolean}
     */
    shouldExecute({ filePath }) {
        if (!this.isEnabled) {
            return true;
        }
        const descriptor = this.fileCache.getFileDescriptor(filePath);
        const meta = descriptor.meta || {};
        // if the config is changed or file is changed, should execute return true
        const isChanged = descriptor.changed || meta.hashOfConfig !== this.config.hash;
        debug(`Skipping file since hasn't changed: ${filePath}`);
        return isChanged;
    }
    didExecute({ result }) {
        if (!this.isEnabled) {
            return;
        }
        const filePath = result.filePath;
        const descriptor = this.fileCache.getFileDescriptor(filePath);
        const meta = descriptor.meta || {};
        /*
         * if a file contains messages we don't want to store the file in the cache
         * so we can guarantee that next execution will also operate on this file
         */
        if (result.messages.length > 0) {
            debug(`File has problems, skipping it: ${filePath}`);
            // remove the entry from the cache
            this.fileCache.removeEntry(filePath);
        }
        else {
            // cache `config.hash`
            meta.hashOfConfig = this.config.hash;
        }
    }
    /**
     * destroy all cache
     */
    destroyCache() {
        this.fileCache.destroy();
    }
    afterAll() {
        // persist cache
        this.fileCache.reconcile();
    }
}
exports.CacheBacker = CacheBacker;
//# sourceMappingURL=cache-backer.js.map