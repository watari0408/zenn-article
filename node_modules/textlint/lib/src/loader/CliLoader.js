"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadCliDescriptor = void 0;
const config_loader_1 = require("@textlint/config-loader");
const kernel_1 = require("@textlint/kernel");
const utils_1 = require("@textlint/utils");
const debug_1 = __importDefault(require("debug"));
const rule_loader_1 = require("../engine/rule-loader");
const debug = (0, debug_1.default)("textlint:cli-loader");
const loadCliDescriptor = (cliOptions) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e;
    const rawRules = Object.create(null);
    const rawPlugins = Object.create(null);
    // --rule
    (_a = cliOptions.rule) === null || _a === void 0 ? void 0 : _a.forEach((rule) => {
        rawRules[(0, utils_1.normalizeTextlintRuleKey)(rule)] = true;
    });
    // --preset
    (_b = cliOptions.preset) === null || _b === void 0 ? void 0 : _b.forEach((preset) => {
        //:support --preset=jtf-style
        if (preset.includes("preset-")) {
            rawRules[preset] = true;
        }
        else {
            rawRules[`preset-${preset}`] = true;
        }
    });
    // --plugin
    (_c = cliOptions.plugin) === null || _c === void 0 ? void 0 : _c.forEach((plugin) => {
        rawPlugins[(0, utils_1.normalizeTextlintPluginKey)(plugin)] = true;
    });
    const result = yield (0, config_loader_1.loadPackagesFromRawConfig)({
        node_moduleDir: cliOptions.rulesBaseDirectory,
        rawConfig: Object.assign(Object.assign({}, (Object.keys(rawRules).length > 0 ? { rules: rawRules } : {})), (Object.keys(rawPlugins).length > 0 ? { plugins: rawPlugins } : {}))
    });
    if (!result.ok) {
        debug("loadPackagesFromRawConfig failed: %o", result);
        throw new Error("Failed to load packages", {
            cause: result.error
        });
    }
    // --rulesdir
    const rulesDirRules = (yield Promise.all((_e = (_d = cliOptions.rulesdir) === null || _d === void 0 ? void 0 : _d.map((rulesdir) => {
        debug("Loading rules from %o", rulesdir);
        return (0, rule_loader_1.loadFromDirAsESM)(rulesdir);
    })) !== null && _e !== void 0 ? _e : [])).flat();
    const { rules, plugins, filterRules } = result.config;
    return new kernel_1.TextlintKernelDescriptor({
        rules: [...rules, ...rulesDirRules],
        plugins,
        filterRules
    });
});
exports.loadCliDescriptor = loadCliDescriptor;
//# sourceMappingURL=CliLoader.js.map